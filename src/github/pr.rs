use anyhow::{Context, Result};
use octocrab::params::pulls::Sort;

use super::GitHubClient;

#[derive(Debug)]
pub struct PrInfo {
    pub number: u64,
    pub state: String,
    pub title: String,
    pub url: String,
    pub is_draft: bool,
}

impl GitHubClient {
    /// Find existing PR for a branch
    pub async fn find_pr(&self, branch: &str) -> Result<Option<PrInfo>> {
        let prs = self
            .octocrab
            .pulls(&self.owner, &self.repo)
            .list()
            .head(format!("{}:{}", self.owner, branch))
            .sort(Sort::Created)
            .send()
            .await
            .context("Failed to list PRs")?;

        if let Some(pr) = prs.items.first() {
            Ok(Some(PrInfo {
                number: pr.number,
                state: pr.state.as_ref().map(|s| format!("{:?}", s)).unwrap_or_default(),
                title: pr.title.clone().unwrap_or_default(),
                url: pr.html_url.as_ref().map(|u| u.to_string()).unwrap_or_default(),
                is_draft: pr.draft.unwrap_or(false),
            }))
        } else {
            Ok(None)
        }
    }

    /// Create a new PR
    pub async fn create_pr(
        &self,
        branch: &str,
        base: &str,
        title: &str,
        body: &str,
        draft: bool,
    ) -> Result<PrInfo> {
        let pr = self
            .octocrab
            .pulls(&self.owner, &self.repo)
            .create(title, branch, base)
            .body(body)
            .draft(Some(draft))
            .send()
            .await
            .context("Failed to create PR")?;

        Ok(PrInfo {
            number: pr.number,
            state: pr.state.as_ref().map(|s| format!("{:?}", s)).unwrap_or_default(),
            title: pr.title.clone().unwrap_or_default(),
            url: pr.html_url.as_ref().map(|u| u.to_string()).unwrap_or_default(),
            is_draft: pr.draft.unwrap_or(false),
        })
    }

    /// Update PR base branch
    pub async fn update_pr_base(&self, pr_number: u64, new_base: &str) -> Result<()> {
        self.octocrab
            .pulls(&self.owner, &self.repo)
            .update(pr_number)
            .base(new_base)
            .send()
            .await
            .context("Failed to update PR base")?;
        Ok(())
    }

    /// Add or update the stack comment on a PR
    pub async fn update_stack_comment(
        &self,
        pr_number: u64,
        stack_comment: &str,
    ) -> Result<()> {
        let comments = self
            .octocrab
            .issues(&self.owner, &self.repo)
            .list_comments(pr_number)
            .send()
            .await
            .context("Failed to list comments")?;

        // Look for existing gt comment
        let marker = "<!-- gt-stack-comment -->";
        let full_comment = format!("{}\n{}", marker, stack_comment);

        for comment in comments.items {
            if comment.body.as_ref().map(|b| b.contains(marker)).unwrap_or(false) {
                // Update existing comment
                self.octocrab
                    .issues(&self.owner, &self.repo)
                    .update_comment(comment.id, &full_comment)
                    .await
                    .context("Failed to update comment")?;
                return Ok(());
            }
        }

        // Create new comment
        self.octocrab
            .issues(&self.owner, &self.repo)
            .create_comment(pr_number, &full_comment)
            .await
            .context("Failed to create comment")?;

        Ok(())
    }
}

/// Generate the stack comment body
pub fn generate_stack_comment(
    branches: &[(String, Option<u64>)], // (branch_name, pr_number)
    current_branch: &str,
) -> String {
    let mut lines = vec![
        "## Stack".to_string(),
        "".to_string(),
    ];

    for (branch, pr_num) in branches {
        let is_current = branch == current_branch;
        let marker = if is_current { "ðŸ‘‰" } else { "  " };

        let pr_link = match pr_num {
            Some(num) => format!(" ([#{}](#))", num),
            None => String::new(),
        };

        lines.push(format!("{} `{}`{}", marker, branch, pr_link));
    }

    lines.push("".to_string());
    lines.push("---".to_string());
    lines.push("*Generated by [gt](https://github.com/cesarferreira/gt)*".to_string());

    lines.join("\n")
}
